package main

import (
	_ "embed"
	"fmt"
	"log"
	"sort"
	"strconv"
	"strings"
)

//go:embed input.txt
var input string

type operator string

const (
	XOR operator = "XOR"
	OR  operator = "OR"
	AND operator = "AND"
)

func (o operator) apply(leftValue, rightValue int) int {
	switch o {
	case XOR:
		return leftValue ^ rightValue
	case OR:
		return leftValue | rightValue
	case AND:
		return leftValue & rightValue
	default:
		panic("invalid operator:" + o)
	}
}

func newOperator(s string) operator {
	switch s {
	case string(XOR):
		return XOR
	case string(AND):
		return AND
	case string(OR):
		return OR
	default:
		panic("invalid operator:" + s)
	}
}

func toNum(s string) int {
	n, err := strconv.Atoi(s)
	if err != nil {
		panic(err)
	}
	return n
}

type gate struct {
	leftVar, rightVar string
	op                operator
	outVar            string
}

type varOp struct {
	op      operator
	output  bool
	operand string
}

type puzzle struct {
	values      map[string]int
	gates       map[string]gate
	gatesByExpr map[string]gate
	varOps      map[string][]gate
	computed    map[string]int
	subst       map[string]string
}

func (z *puzzle) dump() {
	var allGates []gate
	for _, g := range z.gates {
		allGates = append(allGates, g)
	}
	sort.Slice(allGates, func(i, j int) bool {
		l := allGates[i]
		r := allGates[j]
		if l.leftVar != r.leftVar {
			return l.leftVar < r.leftVar
		}
		return l.rightVar < r.rightVar
	})
	for _, g := range allGates {
		fmt.Printf("%s %s %s -> %s\n", g.leftVar, g.op, g.rightVar, g.outVar)
	}

	var keys []string
	for k := range z.varOps {
		keys = append(keys, k)
	}
	sort.Strings(keys)
}

func (z *puzzle) getValueOf(x string) (ret int) {
	v, ok := z.computed[x]
	if ok {
		return v
	}
	defer func() {
		z.computed[x] = ret
	}()
	g, ok := z.gates[x]
	if !ok {
		panic("internal error, no variable:" + x)
	}
	l := z.getValueOf(g.leftVar)
	r := z.getValueOf(g.rightVar)
	return g.op.apply(l, r)
}

func (z *puzzle) init() {
	z.computed = map[string]int{}
	for k, v := range z.values {
		z.computed[k] = v
	}
	z.subst = map[string]string{}
}

func (z *puzzle) computeOutput(prefix string, num int) int {
	output := 0
	for i := num - 1; i >= 0; i-- {
		variable := fmt.Sprintf("%s%02d", prefix, i)
		v := z.getValueOf(variable)
		output |= v
		if i > 0 {
			output = output << 1
		}
	}
	return output
}

func (z *puzzle) compute(numZs int) int {
	return z.computeOutput("z", numZs)
}

func (z *puzzle) part1() (output int, numZs int) {
	z.init()
	var zs []string
	for k := range z.gates {
		if strings.HasPrefix(k, "z") {
			zs = append(zs, k)
		}
	}
	sort.Strings(zs)
	return z.compute(len(zs)), len(zs)
}

type bitAdder struct {
	in1, in2    string // left, right input variables
	inputCarry  string // carry input, may be blank for the first bit
	outXOR      string // in1 ^ in2
	outAND      string // in1 & in2
	outSum      string // outXOR ^ inputCarry
	carryAND    string // outXOR & inputCarry
	outputCarry string // outAND | carryAND
}

func makeExpr(in1 string, op operator, in2 string) string {
	if in1 > in2 {
		in1, in2 = in2, in1
	}
	return fmt.Sprintf("%s %s %s", in1, op, in2)
}

func (z *puzzle) findExprOutput(in1 string, op operator, in2 string) (string, bool) {
	if s1, ok := z.subst[in1]; ok {
		in1 = s1
	}
	if s2, ok := z.subst[in2]; ok {
		in2 = s2
	}
	e := makeExpr(in1, op, in2)
	g, ok := z.gatesByExpr[e]
	if !ok {
		return "", false
	}
	return g.outVar, true
}

func (z *puzzle) newAdder(i int, carry string) (ret bitAdder) {
	log.Println("adder:", i, carry)
	defer func() {
		log.Printf("adder: %+v", ret)
	}()
	in1, in2 := fmt.Sprintf("x%02d", i), fmt.Sprintf("y%02d", i)
	b := bitAdder{
		in1:        in1,
		in2:        in2,
		inputCarry: carry,
	}
	b.outXOR, _ = z.findExprOutput(in1, XOR, in2)
	b.outAND, _ = z.findExprOutput(in1, AND, in2)

	// no input carry for the first
	if b.inputCarry == "" {
		b.outSum = b.outXOR
		b.carryAND = ""
		b.outputCarry = b.outAND
	} else {
		var ok bool
		b.outSum, ok = z.findExprOutput(b.outXOR, XOR, b.inputCarry)
		if !ok {
			log.Printf("no out sum for %d: %s", i, makeExpr(b.outXOR, XOR, b.inputCarry))
		}
		b.carryAND, ok = z.findExprOutput(b.outXOR, AND, b.inputCarry)
		if !ok {
			log.Printf("no carry-and for %d: %s", i, makeExpr(b.outXOR, AND, b.inputCarry))
		}
		b.outputCarry, ok = z.findExprOutput(b.outAND, OR, b.carryAND)
		if !ok {
			log.Printf("no output carry for %d: %s", i, makeExpr(b.outAND, OR, b.carryAND))
		}
	}
	if b.outSum != fmt.Sprintf("z%02d", i) {
		log.Printf("unexpected output for %d: %s", i, b.outSum)
	}
	return b
}

type signature string

const (
	sigUnknown  signature = "unknown"
	sigOutput   signature = "output"
	sigCarry    signature = "carry"
	sigOutXor   signature = "outXOR"
	sigOutAnd   signature = "outAND"
	sigCarryAnd signature = "carryAND"
)

/*
	outXOR -> in1 ^ in2 			 [ OUTPUT a ^ b ]
				outXOR ^ inputCarry  [ ^ n ]
				outXOR & inputCarry  [ & n ]

	outAND -> in1 & in2				 [ OUTPUT a & b ]
				outAND | carryAND    [ | n]

	outSUM  -> outXOR ^ inputCarry   [ OUTPUT a ^ b ]

	carryAND -> outXOR & inputCarry   [ OUTPUT a & b ]
				outAND & carryAND     [ & n ]

	carry ->  outAND & carryAND [OUTPUT a | b]
				outXOR ^ inputCarry  [ ^ n ]
				outXOR & inputCarry  [ & n ]


*/

type displayOp struct {
	output operator
	op1    operator
	op2    operator
}

func (d displayOp) String() string {
	return fmt.Sprintf("%s : %s %s", d.output, d.op1, d.op2)
}

func matchesSignatures(name string, ops []varOp, isLastOutput bool) (ret signature) {
	var dop displayOp
	defer func() {
		dop.output = ops[0].op
		if len(ops) > 1 {
			dop.op1 = ops[1].op
		}
		if len(ops) > 2 {
			dop.op2 = ops[2].op
		}
		fmt.Printf("%s %s -> %v\n", name, dop, ret)
	}()
	sort.Slice(ops, func(i, j int) bool {
		a, b := ops[i], ops[j]
		if a.output != b.output {
			return a.output // true first
		}
		return a.op < b.op
	})
	sigs := map[signature][]varOp{
		sigOutput:   {{XOR, true}},
		sigCarry:    {{OR, true}, {AND, false}, {XOR, false}},
		sigOutXor:   {{XOR, true}, {AND, false}, {XOR, false}},
		sigOutAnd:   {{AND, true}, {OR, false}},
		sigCarryAnd: {{AND, true}, {OR, false}},
	}

	for s, array := range sigs {
		if len(array) != len(ops) {
			continue
		}
		found := true
		for i, op := range array {
			if op != ops[i] {
				found = false
				break
			}
		}
		if found {
			return s
		}
	}
	if isLastOutput && len(ops) == 1 && ops[0].op == OR && ops[0].output {
		return sigOutput
	}
	return sigUnknown
}

func (z *puzzle) part2(numZs int) []string {
	var badVars []string
	lastOutput := fmt.Sprintf("z%02d", numZs-1)
	z.init()
	out := z.compute(numZs)
	x := z.computeOutput("x", numZs-1)
	y := z.computeOutput("y", numZs-1)
	expected := x + y
	log.Printf("Expected: %d %b", expected, expected)
	log.Printf("  Actual: %d %b", out, out)
	log.Printf("    diff: %14d %046b", out^expected, out^expected)

	for v := range z.computed {
		if _, ok := z.values[v]; ok {
			continue // ignore input values
		}
		ops := z.varOps[v]
		sig := matchesSignatures(v, ops, v == lastOutput)
		if sig == sigUnknown {
			badVars = append(badVars, v)
		}
	}
	sort.Strings(badVars)
	return badVars
}

func (z *puzzle) part2a(numZs int) []string {
	var adders []bitAdder
	var badVars []string
	carry := ""
	for i := 0; i < numZs-1; i++ {
		a := z.newAdder(i, carry)
		wantOut := fmt.Sprintf("z%02d", i)
		if a.outSum != wantOut {
			badVars = append(badVars, a.outSum)
			badVars = append(badVars, wantOut)
			z.subst[a.outSum] = wantOut
			z.subst[wantOut] = a.outSum
		}
		adders = append(adders, a)
		carry = a.outputCarry
	}
	return nil
}

func main() {
	lines := strings.Split(strings.TrimSpace(input), "\n")
	values := map[string]int{}
	gatesByOutput := map[string]gate{}
	gatesByExpr := map[string]gate{}
	varOps := map[string][]gate{}

	assign := true
	for _, l := range lines {
		if assign {
			if l == "" {
				assign = false
				continue
			}
			parts := strings.Split(l, ": ")
			values[parts[0]] = toNum(parts[1])
			continue
		}
		parts := strings.Split(l, " ")
		if len(parts) != 5 {
			panic("bad line: " + l)
		}
		g := gate{
			leftVar:  parts[0],
			op:       newOperator(parts[1]),
			rightVar: parts[2],
			outVar:   parts[4],
		}
		if g.leftVar > g.rightVar {
			g.leftVar, g.rightVar = g.rightVar, g.leftVar
		}
		gatesByOutput[parts[4]] = g
		gatesByExpr[makeExpr(g.leftVar, g.op, g.rightVar)] = g

		varOps[g.outVar] = append(varOps[g.outVar], g)
		varOps[g.leftVar] = append(varOps[g.leftVar], g)
		varOps[g.rightVar] = append(varOps[g.rightVar], g)
	}

	puz := &puzzle{
		values:      values,
		gates:       gatesByOutput,
		gatesByExpr: gatesByExpr,
		varOps:      varOps,
	}
	//puz.dump()
	log.Println("num variables:", len(gatesByOutput))
	output, _ := puz.part1()
	log.Println(output)
	log.Println("BAD VARS:", strings.Join(puz.part2(46), ","))
	puz.part2a(46)
}
